<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>üö¶ Next-Gen 3D Traffic Control System</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;700&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: 'Outfit', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; 
            background: #020617;
            overflow: hidden; 
        }
        #canvas-container { width: 100vw; height: 100vh; position: relative; }
        
        /* Control Panel */
        #control-panel {
            position: absolute; top: 20px; left: 20px; z-index: 100;
            background: rgba(15, 23, 42, 0.85); backdrop-filter: blur(20px);
            border-radius: 24px; padding: 25px; width: 360px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            max-height: 90vh; overflow-y: auto;
            color: #f8fafc;
        }
        
        h1 {
            font-size: 1.6rem; margin-bottom: 20px;
            background: linear-gradient(to right, #60a5fa, #a855f7);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: 800; text-align: center;
        }
        
        .section {
            margin-bottom: 18px; padding-bottom: 18px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }
        .section:last-child { border-bottom: none; }
        
        .label {
            display: block; margin-bottom: 10px; font-size: 0.7rem;
            color: #94a3b8; text-transform: uppercase; font-weight: 700;
            letter-spacing: 1.5px;
        }
        
        select, button, input[type="range"] {
            width: 100%; padding: 12px; border-radius: 14px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            background: rgba(30, 41, 59, 0.5); color: #f1f5f9;
            font-size: 0.9rem; cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            margin-bottom: 8px;
        }
        
        button:hover {
            background: rgba(59, 130, 246, 0.2);
            border-color: #3b82f6; transform: translateY(-1px);
        }
        
        button:active { transform: translateY(0); }
        
        .btn-emergency {
            background: linear-gradient(135deg, #ef4444, #991b1b) !important;
            border: none !important; font-weight: 700;
        }
        
        .stat-grid {
            display: grid; grid-template-columns: 1fr 1fr; gap: 10px;
        }
        .stat-card {
            background: rgba(255, 255, 255, 0.03); padding: 12px;
            border-radius: 16px; text-align: center;
        }
        .stat-label { font-size: 0.65rem; color: #64748b; text-transform: uppercase; display: block; }
        .stat-value { font-size: 1rem; font-weight: 700; color: #3b82f6; }
        
        .ped-controls { display: flex; gap: 10px; align-items: center; }

        #loader {
            position: absolute; inset: 0; z-index: 1000;
            background: #020617; display: flex; flex-direction: column;
            align-items: center; justify-content: center; color: white;
        }
        .spinner {
            width: 50px; height: 50px; border: 3px solid rgba(59, 130, 246, 0.1);
            border-top-color: #3b82f6; border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* Responsive Adjustments */
        @media (max-width: 768px) {
            #control-panel { 
                width: calc(100% - 40px); 
                top: 10px; left: 10px; 
                padding: 15px; 
            }
            h1 { font-size: 1.2rem; }
            .stat-grid { grid-template-columns: 1fr 1fr; }
        }

        /* Minimize Logic */
        #control-panel.minimized .section { display: none; }
        #control-panel.minimized h1 { margin-bottom: 0; }
        #control-panel.minimized { width: auto; max-width: 360px; }

        #toggle-btn {
            position: absolute; top: 15px; right: 15px;
            width: 30px; height: 30px; padding: 0; margin: 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px; display: flex; align-items: center;
            justify-content: center; font-size: 1.2rem;
            border: 1px solid rgba(255,255,255,0.1);
        }
    </style>
</head>
<body>
    <div id="loader">
        <div class="spinner"></div>
        <h2 style="margin-top: 20px;">Deploying AI Traffic Infrastructure...</h2>
    </div>

    <div id="control-panel">
        <button id="toggle-btn" onclick="app.togglePanel()">‚àí</button>
        <h1>TRAFFIC CONTROL SYSTEM</h1>
        
        <div class="section">
            <span class="label">üåç Global Environment</span>
            <select id="scenario-select" onchange="app.loadScenario(this.value)">
                <option value="normal">‚òÄÔ∏è Sunny Day - Crystal Clear</option>
                <option value="night">üåô Midnight - Realistic Glow</option>
                <option value="rush">üöó Peak Rush Hour</option>
                <option value="rain">‚õàÔ∏è Heavy Rain - Slick Roads</option>
                <option value="outage">üöß System Power Outage</option>
            </select>
        </div>
        
        <div class="section">
            <span class="label">üîß Traffic Settings</span>
            <button onclick="app.spawnCar()">‚ûï Add Smart Vehicle</button>
            <button class="btn-emergency" onclick="app.triggerEmergency()">üö® SUMMON AMBULANCE</button>
            
            <div class="ped-controls" style="margin-top: 10px;">
                <div style="flex: 1;">
                   <span class="label">üö∂ Pedestrians</span>
                   <input type="range" id="ped-count" min="1" max="10" value="4">
                </div>
                <button onclick="app.spawnPedestrians()" style="width: auto; margin: 0;">Spawn</button>
            </div>
            <button onclick="app.reset()" style="margin-top: 10px; background: rgba(239, 68, 68, 0.1); color: #f87171; border-color: rgba(239, 68, 68, 0.2);">Reset World</button>
        </div>
        
        <div class="section">
            <span class="label">üìà Real-time Analytics</span>
            <div class="stat-grid">
                <div class="stat-card">
                    <span class="stat-label">Active Phase</span>
                    <span class="stat-value" id="phase-display">NORTH</span>
                </div>
                <div class="stat-card">
                    <span class="stat-label">Green Timer</span>
                    <span class="stat-value" id="green-timer">0s</span>
                </div>
                <div class="stat-card">
                    <span class="stat-label">Active Cars</span>
                    <span class="stat-value" id="car-count">0</span>
                </div>
                <div class="stat-card">
                    <span class="stat-label">Efficiency</span>
                    <span class="stat-value" id="efficiency">100%</span>
                </div>
            </div>
        </div>
    </div>
    
    <div id="canvas-container"></div>

    <script src="libs/three.min.js" onerror="alert('Three.js failed to load from libs/')"></script>
    <script src="libs/OrbitControls.js" onerror="alert('OrbitControls failed to load from libs/')"></script>

    <script>
        const CONFIG = {
            STOP_DISTANCE: 165,    // Shifted back to stop before signal poles
            FOLLOW_DISTANCE: 70,
            NORMAL_SPEED: 4.5,
            EMERGENCY_SPEED: 7.8,
            BASE_PHASE_DURATION: 10.0,
            DENSITY_MULTIPLIER: 4.0,
            MAX_PHASE_DURATION: 35.0,
            YELLOW_DURATION: 3.0,
            MAX_CARS_PER_ROAD: 5,
        };

        class SmartTrafficSystem {
            constructor() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 8000);
                this.camera.position.set(500, 450, 500);
                
                this.renderer = new THREE.WebGLRenderer({ 
                    antialias: true, 
                    powerPreference: "high-performance",
                    logarithmicDepthBuffer: true // Prevents flickering at high zoom out levels
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
                this.renderer.outputEncoding = THREE.sRGBEncoding;
                document.getElementById('canvas-container').appendChild(this.renderer.domElement);
                
                this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                
                this.clock = new THREE.Clock();
                this.vehicles = [];
                this.pedestrians = [];
                this.trafficLights = {};
                this.streetLights = [];
                this.buildingWindows = [];
                
                this.currentPhase = 0; 
                this.phaseState = 'green';
                this.phaseTime = 0; // CRITICAL: Missing initialization fixed
                this.waitingTimes = { N: 0, E: 0, S: 0, W: 0 };
                this.powerOutage = false;
                this.isRaining = false;
                this.rainParticles = null;
                this.ambulanceTimer = 0;
                this.ambulanceIteration = 1;
                this.isInitialPhase = true;
                this.init();
            }

            async init() {
                this.buildEnvironment();
                this.createTrafficLights();
                this.setupLights();
                this.loadScenario('normal');
                
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });

                document.getElementById('loader').style.display = 'none';
                this.animate();
            }

            buildEnvironment() {
                // Deep Emerald Ground (#043915)
                const groundGeo = new THREE.PlaneGeometry(3000, 3000);
                const groundMat = new THREE.MeshStandardMaterial({ color: 0x043915, roughness: 1 });
                const ground = new THREE.Mesh(groundGeo, groundMat);
                ground.rotation.x = -Math.PI / 2;
                ground.receiveShadow = true;
                this.scene.add(ground);

                // Professional 4-Lane Road (150 width)
                const roadMat = new THREE.MeshLambertMaterial({ color: 0x1e293b });
                const roadNS = new THREE.Mesh(new THREE.PlaneGeometry(150, 3000), roadMat);
                roadNS.rotation.x = -Math.PI / 2;
                roadNS.position.y = 0.5; // Raised from 1.0
                this.scene.add(roadNS);
                
                const roadEW = new THREE.Mesh(new THREE.PlaneGeometry(3000, 150), roadMat);
                roadEW.rotation.x = -Math.PI / 2;
                roadEW.position.y = 0.6; // Raised from 1.1
                this.scene.add(roadEW);

                // Optimized Road Markings (Instanced for Performance)
                const centerLineMat = new THREE.MeshBasicMaterial({ color: 0xfde047 });
                const laneLineMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                
                const cyNS_Inst = new THREE.InstancedMesh(new THREE.PlaneGeometry(2, 60), centerLineMat, 100);
                const cyEW_Inst = new THREE.InstancedMesh(new THREE.PlaneGeometry(60, 2), centerLineMat, 100);
                const lnNS_Inst = new THREE.InstancedMesh(new THREE.PlaneGeometry(1.5, 30), laneLineMat, 100);
                const lnEW_Inst = new THREE.InstancedMesh(new THREE.PlaneGeometry(30, 1.5), laneLineMat, 100);
                
                let cIdx = 0, lIdx = 0;
                const d = new THREE.Object3D();

                for(let i = -1400; i < 1400; i += 60) {
                    if (Math.abs(i) < 120) continue;
                    
                    // NS Center
                    d.rotation.x = -Math.PI/2; d.position.set(2, 0.75, i); d.updateMatrix(); cyNS_Inst.setMatrixAt(cIdx, d.matrix);
                    d.position.x = -2; d.updateMatrix(); cyNS_Inst.setMatrixAt(cIdx + 1, d.matrix);
                    
                    // EW Center
                    d.position.set(i, 0.8, 2); d.updateMatrix(); cyEW_Inst.setMatrixAt(cIdx, d.matrix);
                    d.position.z = -2; d.updateMatrix(); cyEW_Inst.setMatrixAt(cIdx + 1, d.matrix);
                    cIdx += 2;

                    // Dashes
                    d.position.set(37, 0.75, i); d.updateMatrix(); lnNS_Inst.setMatrixAt(lIdx, d.matrix);
                    d.position.x = -37; d.updateMatrix(); lnNS_Inst.setMatrixAt(lIdx + 1, d.matrix);
                    
                    d.position.set(i, 0.8, 37); d.updateMatrix(); lnEW_Inst.setMatrixAt(lIdx, d.matrix);
                    d.position.z = -37; d.updateMatrix(); lnEW_Inst.setMatrixAt(lIdx + 1, d.matrix);
                    lIdx += 2;
                }
                cyNS_Inst.count = cIdx; cyEW_Inst.count = cIdx;
                lnNS_Inst.count = lIdx; lnEW_Inst.count = lIdx;
                this.scene.add(cyNS_Inst, cyEW_Inst, lnNS_Inst, lnEW_Inst);

                // Curbings
                const curbMat = new THREE.MeshStandardMaterial({ color: 0x334155 });
                const curbs = [
                    { w: 10, h: 3000, x: 80, z: 0 }, { w: 10, h: 3000, x: -80, z: 0 },
                    { w: 3000, h: 10, x: 0, z: 80 }, { w: 3000, h: 10, x: 0, z: -80 }
                ];
                curbs.forEach(c => {
                    const curb = new THREE.Mesh(new THREE.PlaneGeometry(c.w, c.h), curbMat);
                    curb.rotation.x = -Math.PI/2; curb.position.set(c.x, 0.4, c.z); this.scene.add(curb);
                });

                // Zebra Markings
                const zebraMat = new THREE.MeshBasicMaterial({ color: 0xf8fafc });
                const crossings = [
                    { x: 0, z: -120, rot: 0 }, { x: 0, z: 120, rot: 0 },
                    { x: -120, z: 0, rot: Math.PI/2 }, { x: 120, z: 0, rot: Math.PI/2 }
                ];
                crossings.forEach(c => {
                    for(let i=-6; i<=6; i++) {
                        const s = new THREE.Mesh(new THREE.PlaneGeometry(8, 40), zebraMat);
                        s.rotation.x = -Math.PI/2; s.rotation.z = c.rot;
                        s.position.set(c.x + (c.rot?0:i*10), 0.71, c.z + (c.rot?i*10:0)); // Raised to 0.71 (below marks)
                        this.scene.add(s);
                    }
                });

                // Society Houses (Professional Dark Roofs)
                const roofColors = [0x1e293b, 0x334155, 0x020617, 0x451a03, 0x422006];
                const houseBodyMat = new THREE.MeshLambertMaterial({ color: 0xf1f5f9 });
                
                const houseWinGeo = new THREE.PlaneGeometry(12, 10);
                const houseWinMat = new THREE.MeshBasicMaterial({ color: 0x000000 }); // Performance optimization
                this.buildingWindows.push(houseWinMat);

                const housesPerSide = 4;
                for (let i = 0; i < 16; i++) {
                    const quadrant = i % 4;
                    const index = Math.floor(i / 4); // 0, 1, 2, 3
                    const row = Math.floor(index / 2);
                    const col = index % 2;
                    
                    let hX, hZ;
                    // Grid-based placement with a small random jitter to avoid overlaps
                    const baseX = 200 + col * 250; 
                    const baseZ = 200 + row * 250;
                    const jitterX = (Math.random() - 0.5) * 80;
                    const jitterZ = (Math.random() - 0.5) * 80;

                    if (quadrant === 0) { hX = baseX + jitterX; hZ = baseZ + jitterZ; }
                    else if (quadrant === 1) { hX = -(baseX + jitterX); hZ = baseZ + jitterZ; }
                    else if (quadrant === 2) { hX = baseX + jitterX; hZ = -(baseZ + jitterZ); }
                    else { hX = -(baseX + jitterX); hZ = -(baseZ + jitterZ); }

                    const houseGrp = new THREE.Group();
                    houseGrp.position.set(hX, 0, hZ);
                    const body = new THREE.Mesh(new THREE.BoxGeometry(45, 25, 45), houseBodyMat);
                    body.position.y = 12.5; body.castShadow = true; houseGrp.add(body);
                    const roof = new THREE.Mesh(new THREE.ConeGeometry(40, 22, 4), new THREE.MeshLambertMaterial({ color: roofColors[i % 5] }));
                    roof.position.y = 36; roof.rotation.y = Math.PI/4; houseGrp.add(roof);
                    
                    const win = new THREE.Mesh(houseWinGeo, houseWinMat);
                    win.position.set(0, 15, 22.6); houseGrp.add(win);
                    const winSide = win.clone(); winSide.position.set(22.6, 15, 0); winSide.rotation.y = Math.PI/2; houseGrp.add(winSide);
                    this.scene.add(houseGrp);
                }

                // Society Street Signs
                const addSign = (x, z, rot, label) => {
                    const group = new THREE.Group();
                    group.position.set(x, 0, z); group.rotation.y = rot;
                    const pole = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 1.5, 45), new THREE.MeshLambertMaterial({color: 0x334155}));
                    pole.position.y = 22.5; group.add(pole);
                    
                    const can = document.createElement('canvas');
                    can.width = 256; can.height = 128;
                    const c = can.getContext('2d');
                    c.fillStyle = '#1e293b'; c.fillRect(0,0,256,128);
                    c.font = 'bold 40px Arial'; c.fillStyle = '#ffffff'; c.textAlign = 'center';
                    c.fillText(label, 128, 75);
                    
                    const board = new THREE.Mesh(new THREE.BoxGeometry(40, 15, 2), new THREE.MeshBasicMaterial({map: new THREE.CanvasTexture(can)}));
                    board.position.y = 40; group.add(board);
                    this.scene.add(group);
                };
                
                addSign(70, 140, 0, "STREET NO1");
                addSign(-70, 140, 0, "STREET NO2");
                addSign(70, -140, Math.PI, "STREET NO3");
                addSign(-70, -140, Math.PI, "STREET NO4");

                // Skyline Buildings (Optimized with Half Windows)
                const winGeo = new THREE.PlaneGeometry(8, 12);
                const winMat = new THREE.MeshBasicMaterial({ color: 0x000000 }); 
                this.buildingWindows.push(winMat);
                const winInst = new THREE.InstancedMesh(winGeo, winMat, 6000); // Throttled from 20000
                let winIdx = 0;
                const winDummy = new THREE.Object3D();

                const buildColors = [0x334155, 0x475569, 0x1e293b, 0x3f6075, 0x4a5d4e]; 
                for (let i = 0; i < 40; i++) {
                    const x = (Math.random() - 0.5) * 4000;
                    const z = (Math.random() - 0.5) * 4000;
                    if (Math.abs(x) < 140 || Math.abs(z) < 140) continue; 
                    if (Math.abs(x) < 850 && Math.abs(z) < 850) continue;
                    
                    const h = 200 + Math.random() * 500;
                    const w = 60 + Math.random() * 80;
                    const b = new THREE.Mesh(new THREE.BoxGeometry(w, h, w), new THREE.MeshLambertMaterial({ color: buildColors[i % 5] }));
                    b.position.set(x, h/2, z); b.castShadow = true; this.scene.add(b);
                    
                    // Add instanced windows (High performance density)
                    const rows = Math.floor(h / 120);
                    const cols = Math.floor(w / 40);
                    for(let r=1; r<rows; r++) {
                        for(let c=1; c<cols; c++) {
                            if (winIdx >= 5998) break;
                            // Front face only for distant buildings
                            winDummy.position.set(x -w/2 + c*40, r*120, z + w/2 + 0.1);
                            winDummy.updateMatrix();
                            winInst.setMatrixAt(winIdx++, winDummy.matrix);
                        }
                    }
                }
                winInst.count = winIdx;
                this.scene.add(winInst);

                // Zig-Zag Street Lamps & Roadside Bushes
                // Optimized Geometry: Instancing for bushes and flowers
                const bushGeo = new THREE.SphereGeometry(6, 6, 6);
                const flowerGeo = new THREE.SphereGeometry(1.5, 4, 4);
                const bushMat = new THREE.MeshLambertMaterial({ color: 0x166534 });
                const flowerColors = [0xef4444, 0xec4899, 0xa855f7];
                
                // Pre-count instances (Approx 1000)
                const bushInst = new THREE.InstancedMesh(bushGeo, bushMat, 1000);
                const flowerInst = new THREE.InstancedMesh(flowerGeo, new THREE.MeshLambertMaterial({color: 0xef4444}), 1000);
                let instIdx = 0;

                const dummy = new THREE.Object3D();

                for(let i = -1400; i < 1400; i += 40) {
                    if (Math.abs(i) < 180) continue;
                    
                    if (i % 80 === 0) {
                        const side = (i % 160 === 0) ? 1 : -1;
                        // Lamps NS
                        const lampNS = new THREE.Group();
                        lampNS.position.set(95 * side, 0, i);
                        const poleNS = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 2.5, 70), new THREE.MeshLambertMaterial({color: 0x020617}));
                        poleNS.position.y = 35; lampNS.add(poleNS);
                        const armNS = new THREE.Mesh(new THREE.BoxGeometry(15, 2, 2), new THREE.MeshLambertMaterial({color: 0x020617}));
                        armNS.position.set(side > 0 ? -7 : 7, 70, 0); lampNS.add(armNS);
                        
                        // BULB EMISSIVE MESH (Replaced expensive Real PointLights with glow materials)
                        const bulbNS = new THREE.Mesh(new THREE.SphereGeometry(3, 8, 8), new THREE.MeshBasicMaterial({color: 0x000000}));
                        bulbNS.position.set(side > 0 ? -12: 12, 70, 0); lampNS.add(bulbNS);
                        this.streetLights.push(bulbNS);
                        this.scene.add(lampNS);

                        const lampEW = new THREE.Group();
                        lampEW.position.set(i, 0, 95 * side);
                        lampEW.rotation.y = Math.PI/2;
                        const poleEW = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 2.5, 70), new THREE.MeshLambertMaterial({color: 0x020617}));
                        poleEW.position.y = 35; lampEW.add(poleEW);
                        const armEW = new THREE.Mesh(new THREE.BoxGeometry(15, 2, 2), new THREE.MeshLambertMaterial({color: 0x020617}));
                        armEW.position.set(side > 0 ? 7 : -7, 70, 0); lampEW.add(armEW);
                        
                        const bulbEW = new THREE.Mesh(new THREE.SphereGeometry(3, 8, 8), new THREE.MeshBasicMaterial({color: 0x000000}));
                        bulbEW.position.set(side > 0 ? 12: -12, 70, 0); lampEW.add(bulbEW);
                        this.streetLights.push(bulbEW);
                        this.scene.add(lampEW);

                        // Bushes (Instanced)
                        const roads = [{x: 88, z: i, rot: 0}, {x: -88, z: i, rot: 0}, {x: i, z: 88, rot: Math.PI/2}, {x: i, z: -88, rot: Math.PI/2}];
                        roads.forEach(r => {
                            const clusterSize = Math.random() < 0.4 ? 2 : 1;
                            for(let c=0; c<clusterSize; c++) {
                                const offset = (c-clusterSize/2) * 8;
                                dummy.position.set(r.x + (r.rot?0:offset/2), 3, r.z + (r.rot?offset/2:0));
                                dummy.scale.set(1, 0.6, 1);
                                dummy.updateMatrix();
                                bushInst.setMatrixAt(instIdx, dummy.matrix);
                                
                                dummy.position.y = 6;
                                dummy.scale.set(1, 1, 1);
                                dummy.updateMatrix();
                                flowerInst.setMatrixAt(instIdx, dummy.matrix);
                                instIdx++;
                            }
                        });
                    }
                }
                bushInst.count = instIdx;
                flowerInst.count = instIdx;
                this.scene.add(bushInst, flowerInst);

                // Rain Particles (Hidden by default)
                const rainGeo = new THREE.BufferGeometry();
                const rainCount = 800; // Optimized from 2000
                const rainPoints = [];
                for(let i=0; i<rainCount; i++) {
                    rainPoints.push((Math.random()-0.5)*1500, Math.random()*800, (Math.random()-0.5)*1500);
                }
                rainGeo.setAttribute('position', new THREE.Float32BufferAttribute(rainPoints, 3));
                const rainMat = new THREE.PointsMaterial({color: 0xaaaaaa, size: 2, transparent: true, opacity: 0});
                this.rainParticles = new THREE.Points(rainGeo, rainMat);
                this.scene.add(this.rainParticles);
            }

            createTrafficLights() {
                const userSigConfig = [
                    { dir: 'N', x: -65, z: -140, rot: Math.PI, arm: 25 }, 
                    { dir: 'S', x: 65, z: 140, rot: 0, arm: 25 },           
                    { dir: 'E', x: 140, z: -65, rot: Math.PI/2, arm: 25 },  
                    { dir: 'W', x: -140, z: 65, rot: -Math.PI/2, arm: 25 }  
                ];

                userSigConfig.forEach(p => {
                    const group = new THREE.Group();
                    group.position.set(p.x, 0, p.z); group.rotation.y = p.rot;
                    
                    const pole = new THREE.Mesh(new THREE.BoxGeometry(4, 70, 4), new THREE.MeshLambertMaterial({color: 0x000000}));
                    pole.position.y = 35; group.add(pole);

                    const arm = new THREE.Mesh(new THREE.BoxGeometry(p.arm, 4, 4), new THREE.MeshLambertMaterial({color: 0x000000}));
                    arm.position.set(p.arm/2, 65, 0); group.add(arm);

                    const box = new THREE.Mesh(new THREE.BoxGeometry(16, 32, 10), new THREE.MeshLambertMaterial({color: 0x000000}));
                    box.position.set(p.arm, 65, 0); group.add(box);
                    
                    const bulbGeo = new THREE.SphereGeometry(4.5, 16, 16);
                    const r = new THREE.Mesh(bulbGeo, new THREE.MeshStandardMaterial({color: 0x220000, emissive: 0x000000}));
                    r.position.set(p.arm, 75, 6); group.add(r);
                    const y = new THREE.Mesh(bulbGeo, new THREE.MeshStandardMaterial({color: 0x222200, emissive: 0x000000}));
                    y.position.set(p.arm, 65, 6); group.add(y);
                    const g = new THREE.Mesh(bulbGeo, new THREE.MeshStandardMaterial({color: 0x002200, emissive: 0x000000}));
                    g.position.set(p.arm, 55, 6); group.add(g);
                    
                    this.scene.add(group);
                    this.trafficLights[p.dir] = { red:r, yellow:y, green:g, state: 'red' };
                });
            }

            setupLights() {
                this.ambient = new THREE.AmbientLight(0xffffff, 1.4); this.scene.add(this.ambient);
                this.sun = new THREE.DirectionalLight(0xffffff, 1.0); this.sun.position.set(600, 1000, 300); this.scene.add(this.sun);
            }

            spawnCar(lane = null, type = 'normal') {
                const lanes = ['N', 'E', 'S', 'W'];
                const targetLane = lane || lanes[Math.floor(Math.random() * 4)];
                
                // Strict Global Limit for Rush Hour
                if (this.isRush && this.vehicles.length >= 20) return;
                
                if (this.vehicles.filter(v => v.lane === targetLane).length >= CONFIG.MAX_CARS_PER_ROAD) return;

                const car = new THREE.Group();
                const categories = ['car', 'jeep', 'bus'];
                const category = type === 'ambulance' ? 'ambulance' : categories[Math.floor(Math.random() * categories.length)];
                
                const colors = [0x3b82f6, 0xef4444, 0x10b981, 0xf59e0b, 0xffffff, 0x8b5cf6];
                const mainColor = type === 'ambulance' ? 0xffffff : colors[Math.floor(Math.random()*colors.length)];
                const mat = new THREE.MeshStandardMaterial({color: mainColor, roughness: 0.1});
                const winMat = new THREE.MeshBasicMaterial({color: 0x000000});
                const wheelMat = new THREE.MeshLambertMaterial({color: 0x111111});
                const wheelGeo = new THREE.CylinderGeometry(3.2, 3.2, 3, 16);
                
                let bodyW = 18, bodyH = 8, bodyL = 32;
                
                // Specific Shape Logic
                if (category === 'car') {
                    bodyH = 6; bodyL = 30;
                    const body = new THREE.Mesh(new THREE.BoxGeometry(bodyW, bodyH, bodyL), mat);
                    body.position.y = 7; body.castShadow = true; car.add(body);
                    const cabin = new THREE.Mesh(new THREE.BoxGeometry(16, 5, 16), mat);
                    cabin.position.set(0, 12, -2); car.add(cabin);
                    // Windows
                    const fw = new THREE.Mesh(new THREE.PlaneGeometry(14, 3.5), winMat);
                    fw.position.set(0, 12, 6.1); car.add(fw);
                    const sw = new THREE.Mesh(new THREE.PlaneGeometry(13, 3.5), winMat);
                    sw.position.set(8.1, 12, -2); sw.rotation.y = Math.PI/2; car.add(sw);
                    const sw2 = sw.clone(); sw2.position.x = -8.1; sw2.rotation.y = -Math.PI/2; car.add(sw2);
                } else if (category === 'jeep') {
                    bodyH = 12; bodyL = 28;
                    const body = new THREE.Mesh(new THREE.BoxGeometry(bodyW, bodyH, bodyL), mat);
                    body.position.y = 10; body.castShadow = true; car.add(body);
                    // Windows
                    const fw = new THREE.Mesh(new THREE.PlaneGeometry(15, 6), winMat);
                    fw.position.set(0, 13, 14.1); car.add(fw);
                    const sw = new THREE.Mesh(new THREE.PlaneGeometry(20, 6), winMat);
                    sw.position.set(9.1, 13, 0); sw.rotation.y = Math.PI/2; car.add(sw);
                    const sw2 = sw.clone(); sw2.position.x = -9.1; sw2.rotation.y = -Math.PI/2; car.add(sw2);
                } else if (category === 'bus') {
                    bodyH = 16; bodyL = 52;
                    const body = new THREE.Mesh(new THREE.BoxGeometry(bodyW, bodyH, bodyL), mat);
                    body.position.y = 12; body.castShadow = true; car.add(body);
                    // Windows
                    const sw = new THREE.Mesh(new THREE.PlaneGeometry(45, 8), winMat);
                    sw.position.set(9.1, 15, 0); sw.rotation.y = Math.PI/2; car.add(sw);
                    const sw2 = sw.clone(); sw2.position.x = -9.1; sw2.rotation.y = -Math.PI/2; car.add(sw2);
                    const fw = new THREE.Mesh(new THREE.PlaneGeometry(15, 10), winMat);
                    fw.position.set(0, 15, 26.1); car.add(fw);
                } else if (category === 'ambulance') {
                    bodyH = 13; bodyL = 34;
                    const body = new THREE.Mesh(new THREE.BoxGeometry(bodyW, bodyH, bodyL), mat);
                    body.position.y = 10.5; body.castShadow = true; car.add(body);
                    // Windows
                    const fw = new THREE.Mesh(new THREE.PlaneGeometry(15, 6), winMat);
                    fw.position.set(0, 13, 17.1); car.add(fw);
                    const sw = new THREE.Mesh(new THREE.PlaneGeometry(12, 5), winMat);
                    sw.position.set(9.1, 13, 8); sw.rotation.y = Math.PI/2; car.add(sw);
                    const sw2 = sw.clone(); sw2.position.x = -9.1; sw2.rotation.y = -Math.PI/2; car.add(sw2);
                }

                // Add 4 Wheels
                const wheelPositions = [
                    {x: 8, z: bodyL/2 - 6}, {x: -8, z: bodyL/2 - 6},
                    {x: 8, z: -bodyL/2 + 6}, {x: -8, z: -bodyL/2 + 6}
                ];
                wheelPositions.forEach(p => {
                    const w = new THREE.Mesh(wheelGeo, wheelMat);
                    w.rotation.z = Math.PI/2;
                    w.position.set(p.x, 3.2, p.z);
                    car.add(w);
                });

                const laneConfigs = {
                    N: { offset: -1, rot: 0, axis: 'z', dir: 1 },
                    S: { offset: 1, rot: Math.PI, axis: 'z', dir: -1 },
                    E: { offset: -1, rot: -Math.PI/2, axis: 'x', dir: -1 },
                    W: { offset: 1, rot: Math.PI/2, axis: 'x', dir: 1 }
                };
                const config = laneConfigs[targetLane];
                
                const isInner = Math.random() < 0.6;
                const laneOffset = isInner ? 22 : 58; 
                // Increased Left Turn chance to 50% for inner lane
                const intent = type === 'ambulance' ? 'straight' : (isInner ? (Math.random() < 0.5 ? 'straight' : 'left') : 'right');

                if (targetLane === 'N' || targetLane === 'S') car.position.x = config.offset * laneOffset;
                else car.position.z = config.offset * laneOffset;

                car.position[config.axis] = (targetLane === 'N' || targetLane === 'W') ? -1400 : 1400;
                car.rotation.y = config.rot;

                let hlColor = 0xfff9c4;
                const hl = new THREE.Mesh(new THREE.CircleGeometry(3, 32), new THREE.MeshBasicMaterial({color: hlColor}));
                hl.position.set(-6, 8, bodyL/2 + 0.1); car.add(hl);
                const hr = hl.clone(); hr.position.x = 6; car.add(hr);
                const beam = new THREE.SpotLight(0xfff08a, 6, 400, 0.5); beam.position.set(0, 8, bodyL/2 + 1);
                const tObj = new THREE.Object3D(); tObj.position.set(0, 0, 100); car.add(tObj);
                beam.target = tObj; car.add(beam);

                const bl = new THREE.Mesh(new THREE.CircleGeometry(3, 32), new THREE.MeshBasicMaterial({color: 0x600000}));
                bl.position.set(-6, 8, -bodyL/2 - 0.1); bl.rotation.y = Math.PI; car.add(bl);
                const br = bl.clone(); br.position.x = 6; car.add(br);

                let sirens = null;
                if(category === 'ambulance') {
                    sirens = new THREE.Mesh(new THREE.BoxGeometry(14, 3, 5), new THREE.MeshBasicMaterial({color: 0xffffff}));
                    sirens.position.y = bodyH + 8; car.add(sirens);
                }

                // Add Blinkers (Orange)
                const blinkerGeo = new THREE.CircleGeometry(1.5, 16);
                const blinkerMat = new THREE.MeshBasicMaterial({color: 0xffa500, transparent: true, opacity: 0});
                const blnt = new THREE.Mesh(blinkerGeo, blinkerMat); 
                blnt.position.set(-8, 8, bodyL/2 + 0.2); car.add(blnt);
                const brnt = blnt.clone(); brnt.position.x = 8; car.add(brnt);
                
                this.scene.add(car);
                const carObj = { 
                    mesh: car, lane: targetLane, type: category, intent: intent, isTurning: false, turnProgress: 0,
                    turnAngle: 0, blinkers: { L: blnt, R: brnt },
                    speed: 0, maxSpeed: category==='ambulance'?CONFIG.EMERGENCY_SPEED:CONFIG.NORMAL_SPEED, 
                    config, brakeLights: [bl, br], headLight: beam, sirens, status: 'moving',
                    originalOffset: laneOffset, isOvertaking: false, overtakeTarget: 0,
                    length: bodyL
                };
                this.vehicles.push(carObj);
            }

            spawnPedestrians() {
                const count = parseInt(document.getElementById('ped-count').value);
                const corners = [
                    { x: -80, z: -150, dx: 0, dz: 1, side: 'N' }, 
                    { x: 80, z: 150, dx: 0, dz: -1, side: 'S' }, 
                    { x: -150, z: 80, dx: 1, dz: 0, side: 'W' }, 
                    { x: 150, z: -80, dx: -1, dz: 0, side: 'E' }
                ];
                
                const clothColors = [0x3b82f6, 0xef4444, 0x10b981, 0xf59e0b, 0xffffff];
                
                corners.forEach(corner => {
                    for(let i=0; i<count; i++) {
                        const group = new THREE.Group();
                        
                        // Head
                        const head = new THREE.Mesh(new THREE.SphereGeometry(2, 8, 8), new THREE.MeshLambertMaterial({color: 0xffdbac}));
                        head.position.y = 14; group.add(head);
                        
                        // Torso (Clothing)
                        const torso = new THREE.Mesh(new THREE.BoxGeometry(3, 6, 2), new THREE.MeshLambertMaterial({color: clothColors[Math.floor(Math.random()*5)]}));
                        torso.position.y = 10; group.add(torso);
                        
                        // Legs
                        const legGeo = new THREE.BoxGeometry(1, 4, 1);
                        const legL = new THREE.Mesh(legGeo, new THREE.MeshLambertMaterial({color: 0x1e293b}));
                        legL.position.set(-1, 5, 0); group.add(legL);
                        const legR = legL.clone();
                        legR.position.x = 1; group.add(legR);
                        
                        group.position.set(corner.x + (corner.dx?0:(Math.random()-0.5)*25), 0, corner.z + (corner.dz?0:(Math.random()-0.5)*25));
                        this.scene.add(group);
                        this.pedestrians.push({ mesh: group, legs: [legL, legR], dir: { x: corner.dx, z: corner.dz }, side: corner.side, distance: 0, status: 'waiting' });
                    }
                });
            }

            updateTrafficLights(dt) {
                const phases = ['NORTH', 'EAST', 'SOUTH', 'WEST'];
                const laneKeys = ['N', 'E', 'S', 'W'];
                this.phaseTime += dt;
                
                const density = { N: 0, E: 0, S: 0, W: 0 };
                this.vehicles.forEach(v => {
                    const dist = Math.abs(v.mesh.position[v.config.axis]);
                    if (dist > CONFIG.STOP_DISTANCE && dist < 500 && (v.mesh.position[v.config.axis] * v.config.dir < 0)) density[v.lane]++;
                });

                if (this.powerOutage) {
                    this.dynamicDuration = CONFIG.BASE_PHASE_DURATION;
                } else if (this.isInitialPhase) {
                    this.dynamicDuration = 15.0; // Fixed 15s for the very first signal
                } else {
                    this.dynamicDuration = Math.min(CONFIG.MAX_PHASE_DURATION, CONFIG.BASE_PHASE_DURATION + (density[laneKeys[this.currentPhase]] * CONFIG.DENSITY_MULTIPLIER));
                    if (this.isRaining || this.isSnowing) this.dynamicDuration += 4.0;
                }

                const activeLane = laneKeys[this.currentPhase];
                const carsClearing = this.vehicles.some(v => 
                    (v.lane === activeLane && Math.abs(v.mesh.position[v.config.axis]) < 120) || // Sharpened: only cars actually IN the box
                    (v.isTurning && Math.abs(v.mesh.position.x) < 160 && Math.abs(v.mesh.position.z) < 160)
                );

                // Density & Waiting Time Trackers
                laneKeys.forEach((lane, idx) => {
                    if (idx !== this.currentPhase && density[lane] > 0) {
                        this.waitingTimes[lane] += dt;
                    } else if (idx === this.currentPhase) {
                        this.waitingTimes[lane] = 0;
                    }
                });

                if (!this.powerOutage && this.phaseState === 'green' && density[activeLane] === 0 && !carsClearing && this.phaseTime > 3.0) {
                    this.dynamicDuration = 3.0;
                }

                const priorityAmbulance = this.vehicles.find(v => v.type === 'ambulance' && Math.abs(v.mesh.position[v.config.axis]) < 700 && (v.mesh.position[v.config.axis] * v.config.dir < 0));
                if (priorityAmbulance) {
                    const ambPhase = laneKeys.indexOf(priorityAmbulance.lane);
                    if (this.currentPhase !== ambPhase || this.phaseState !== 'green') {
                        this.currentPhase = ambPhase;
                        this.phaseState = 'green';
                        this.phaseTime = 0;
                    }
                }
                
                if(this.phaseTime > (this.phaseState === 'green' ? this.dynamicDuration : CONFIG.YELLOW_DURATION)) {
                    // Safety Force Switch: Max 45s limit to prevent signal deadlocks from stuck cars
                    const forceSwitch = (this.phaseState === 'green' && this.phaseTime > 45);
                    if (!this.isInitialPhase && this.phaseState === 'green' && carsClearing && !priorityAmbulance && !forceSwitch) return; 

                    if (this.phaseState === 'green') { 
                        this.phaseState = 'yellow'; 
                        this.phaseTime = 0; 
                        this.isInitialPhase = false; 
                    } else { 
                        this.phaseState = 'green'; 
                        this.phaseTime = 0; 
                        
                        let bestScore = -1;
                        let nextPhase = (this.currentPhase + 1) % 4;

                        laneKeys.forEach((lane, idx) => {
                            const score = (density[lane] * 2.5) + (this.waitingTimes[lane] * 0.8);
                            if (score > bestScore) {
                                bestScore = score;
                                nextPhase = idx;
                            }
                        });
                        
                        this.currentPhase = nextPhase;
                        this.waitingTimes[laneKeys[this.currentPhase]] = 0; 
                    }
                }

                Object.keys(this.trafficLights).forEach(dir => {
                    const l = this.trafficLights[dir];
                    const active = (dir === laneKeys[this.currentPhase]);
                    
                    // Logical State for Vehicles
                    if (active) {
                        l.state = (this.phaseState === 'green') ? 'green' : 'yellow';
                    } else {
                        l.state = 'red';
                    }

                    // Visual Rendering
                    if (this.powerOutage) {
                        const blink = Math.floor(this.clock.elapsedTime * 2) % 2;
                        l.red.material.emissive.setHex(0);
                        l.green.material.emissive.setHex(0);
                        l.yellow.material.emissive.setHex(blink ? 0xffea00 : 0);
                    } else {
                        if (l.state === 'green') { l.red.material.emissive.setHex(0); l.yellow.material.emissive.setHex(0); l.green.material.emissive.setHex(0x00ff00); }
                        else if (l.state === 'yellow') { l.red.material.emissive.setHex(0); l.yellow.material.emissive.setHex(0xffff00); l.green.material.emissive.setHex(0); }
                        else { l.red.material.emissive.setHex(0xff0000); l.yellow.material.emissive.setHex(0); l.green.material.emissive.setHex(0); }
                    }
                });
                
                document.getElementById('phase-display').innerText = this.powerOutage ? "OUTAGE" : phases[this.currentPhase];
                document.getElementById('green-timer').innerText = Math.ceil((this.phaseState==='green'?this.dynamicDuration:CONFIG.YELLOW_DURATION) - this.phaseTime) + "s";
            }

            updateVehicles(dt) {
                for (let i = this.vehicles.length - 1; i >= 0; i--) {
                    const v = this.vehicles[i];
                    const pos = v.mesh.position;
                    let axis = v.config.axis;
                    let dir = v.config.dir;
                    const dist = Math.abs(pos[axis]);
                    const movingTowardsCenter = (pos[axis] * dir < 0);
                    let target = v.maxSpeed;
                    v.status = 'moving';

                    // 1. LIGHT RADIUS (Only for cars moving towards the intersection)
                    if (movingTowardsCenter && !v.isTurning) {
                        const light = this.trafficLights[v.lane];
                        if ((light.state === 'red' || light.state === 'yellow') && v.type !== 'ambulance') {
                            const distToLine = dist - CONFIG.STOP_DISTANCE;
                            if (distToLine > 0) {
                                target = Math.max(0, Math.min(v.maxSpeed, distToLine / 25)); 
                                if (distToLine < 15) v.status = 'braking'; 
                            } else { target = 0; }
                        } else if (dist < (v.intent === 'left' ? 40 : 120) && v.intent !== 'straight') {
                            v.isTurning = true; v.turnAngle = 0;
                        }
                    }

                        // 2. UNIVERSAL COLLISION RADAR (Smart Awareness)
                        for (let j = 0; j < this.vehicles.length; j++) {
                            const other = this.vehicles[j];
                            if (other === v) continue;
                            
                            // Turning Priority: Ignore cars in other lanes that are waiting at lights
                            if (v.isTurning && !other.isTurning && v.lane !== other.lane && other.speed < 0.1) continue;
                            
                            // Straight Priority: Yield to anyone ALREADY in the intersection (The Box Rule)
                            if (!v.isTurning && other.isTurning && Math.abs(other.mesh.position.x) < 100 && Math.abs(other.mesh.position.z) < 100) {
                                if (pos.distanceTo(other.mesh.position) < 130) { target = 0; v.status = 'braking'; continue; }
                            }

                            if (!v.isTurning && !other.isTurning && !v.isOvertaking && v.lane !== other.lane) continue;

                        const d = pos.distanceTo(other.mesh.position);
                        if (d > 200) continue; 

                        const relDir = other.mesh.position.clone().sub(pos).normalize();
                        const fwd = new THREE.Vector3(0, 0, 1).applyQuaternion(v.mesh.quaternion);
                        
                        if (relDir.dot(fwd) > 0.4) {
                            // Ambulance Priority Overtake Trigger
                            if (v.type === 'ambulance' && !v.isTurning && !v.isOvertaking && d < 150 && other.speed < v.maxSpeed * 0.8) {
                                const otherSideOffset = v.originalOffset === 22 ? 58 : 22;
                                const sideAxis = axis === 'x' ? 'z' : 'x';
                                const gapReq = this.isRush ? 65 : 100;
                                const laneClear = !this.vehicles.some(v2 => v2 !== v && Math.abs(v2.mesh.position[sideAxis] - (v.config.offset * otherSideOffset)) < 15 && Math.abs(v2.mesh.position[axis] - pos[axis]) < gapReq);
                                if (laneClear) { v.isOvertaking = true; v.overtakeTarget = v.config.offset * otherSideOffset; }
                            }
                            
                            if (!v.isOvertaking || v.type !== 'ambulance') {
                                const minSafe = (v.length/2 + other.length/2) + 12;
                                target = Math.min(target, other.speed * 0.9);
                                if (d < minSafe) { target = 0; v.status = 'braking'; }
                            }
                        }
                    }

                    // 3. AMBULANCE OVERTAKE EXECUTION
                    if (v.isOvertaking && !v.isTurning) {
                        const sideAxis = axis === 'x' ? 'z' : 'x';
                        const shift = (v.overtakeTarget - pos[sideAxis]);
                        if (Math.abs(shift) > 1) {
                            pos[sideAxis] += Math.sign(shift) * 1.5;
                        } else {
                            const blocking = this.vehicles.find(v2 => v2 !== v && Math.abs(v2.mesh.position[sideAxis] - (v.config.offset * v.originalOffset)) < 15 && (v2.mesh.position[axis] - pos[axis]) * dir > -80 && (v2.mesh.position[axis] - pos[axis]) * dir < 120);
                            if (!blocking) {
                                const clear = !this.vehicles.some(v2 => v2 !== v && Math.abs(v2.mesh.position[sideAxis] - (v.config.offset * v.originalOffset)) < 15 && Math.abs(v2.mesh.position[axis] - pos[axis]) < 120);
                                if (clear && Math.abs(pos[axis]) > 200) {
                                    v.overtakeTarget = v.config.offset * v.originalOffset;
                                    if (Math.abs(pos[sideAxis] - v.overtakeTarget) < 2) v.isOvertaking = false;
                                }
                            }
                        }
                    }

                    // 4. SPEED & POSITION UPDATE (Unlocked for all states)
                    if (v.speed < target) v.speed += 0.4;
                    else if (v.speed > target) v.speed -= (this.isRaining || this.isSnowing) ? 0.6 : 1.2;
                    if (v.speed < 0.1) v.speed = 0;

                    if (v.isTurning) {
                        const isLeft = v.intent === 'left';
                        const radius = isLeft ? 90 : 38;
                        const turnStep = (v.speed / radius);
                        
                        // 1. Left Turn Yield Logic: Only yield if oncoming traffic is actually moving and close
                        let yieldForCross = false;
                        if (isLeft && v.turnAngle < Math.PI/3) {
                            yieldForCross = this.vehicles.some(other => 
                                other !== v && !other.isTurning && other.lane === (v.lane === 'N' ? 'S' : v.lane === 'S' ? 'N' : v.lane === 'E' ? 'W' : 'E') &&
                                other.speed > 0.5 && // Only yield if they are actually moving
                                Math.abs(other.mesh.position.distanceTo(pos)) < 110
                            );
                        }

                        if (!yieldForCross) {
                            v.mesh.rotation.y += isLeft ? turnStep : -turnStep;
                            v.turnAngle += turnStep;
                            v.mesh.translateZ(v.speed);
                        } else { 
                            v.status = 'braking'; 
                            target = 0; // Proper stop for yielding
                        }

                        if (v.turnAngle >= Math.PI * 0.485) { 
                            v.isTurning = false;
                            v.mesh.rotation.y = Math.round(v.mesh.rotation.y / (Math.PI/2)) * (Math.PI/2);
                            const ang = ((v.mesh.rotation.y % (Math.PI*2)) + (Math.PI*2)) % (Math.PI*2);
                            if (Math.abs(ang % Math.PI) < 0.1) { 
                                v.config.axis = 'z'; v.config.dir = (Math.abs(ang) < 0.1) ? 1 : -1; 
                                v.lane = (v.config.dir === 1) ? 'N' : 'S';
                            } else { 
                                v.config.axis = 'x'; v.config.dir = (Math.abs(ang - Math.PI/2) < 0.1) ? 1 : -1; 
                                v.lane = (v.config.dir === -1) ? 'E' : 'W';
                            }
                            v.intent = 'straight';
                        }
                    } else {
                        pos[axis] += v.speed * dir;
                    }

                    // Blinker Logic (Improved side-selective)
                    if (v.intent !== 'straight' || v.isTurning) {
                        const flash = Math.floor(Date.now() / 400) % 2;
                        const side = v.intent === 'left' ? 'L' : 'R';
                        v.blinkers.L.material.opacity = (side === 'L' && flash) ? 1 : 0;
                        v.blinkers.R.material.opacity = (side === 'R' && flash) ? 1 : 0;
                    } else {
                        v.blinkers.L.material.opacity = v.blinkers.R.material.opacity = 0;
                    }

                    v.brakeLights.forEach(l => l.material.color.setHex((v.status === 'braking' || v.speed < 0.2) ? 0xff0000 : 0x400000));
                    if(v.sirens) {
                        const flash = Math.floor(Date.now() / 150) % 2;
                        v.sirens.material.color.setHex(flash ? 0xff0000 : 0xffffff);
                    }
                    if (dist > 1500) { this.scene.remove(v.mesh); this.vehicles.splice(i, 1); }
                }
                document.getElementById('car-count').innerText = this.vehicles.length;
            }

            updatePedestrians(dt) {
                for (let i = this.pedestrians.length - 1; i >= 0; i--) {
                    const p = this.pedestrians[i];
                    const light = this.trafficLights[p.side];
                    let canWalk = (light.state === 'red'); // Pedestrians cross when vehicle signal is RED

                    // If they haven't reached the crossing yet, or they are already crossing
                    const isAtCrossing = (p.distance > 20 && p.distance < 160);
                    
                    if (isAtCrossing && !canWalk) {
                        p.status = 'waiting';
                    } else {
                        p.status = 'walking';
                        p.distance += 0.8;
                        p.mesh.position.x += p.dir.x * 0.8;
                        p.mesh.position.z += p.dir.z * 0.8;
                        
                        // Walking Animation
                        p.mesh.position.y = Math.abs(Math.sin(p.distance * 0.2)) * 1;
                        p.legs[0].rotation.x = Math.sin(p.distance * 0.2) * 0.5;
                        p.legs[1].rotation.x = -Math.sin(p.distance * 0.2) * 0.5;
                    }

                    if (p.distance > 350) {
                        this.scene.remove(p.mesh);
                        this.pedestrians.splice(i, 1);
                    }
                }
            }

            triggerEmergency() { this.spawnCar(null, 'ambulance'); }
            reset() { this.vehicles.forEach(v => this.scene.remove(v.mesh)); this.vehicles = []; this.pedestrians.forEach(p => this.scene.remove(p.mesh)); this.pedestrians = []; this.phaseTime = 0; }
            
            loadScenario(s) { 
                // Removed this.reset() to prevent world clearing during transitions
                this.powerOutage = (s === 'outage');
                this.isRaining = (s === 'rain');
                this.isSnowing = (s === 'snow');
                this.isFoggy = (s === 'fog');
                this.isScramble = (s === 'scramble');
                this.isRush = (s === 'rush');
                
                CONFIG.MAX_CARS_PER_ROAD = this.isRush ? 15 : 5;
                CONFIG.NORMAL_SPEED = this.isRush ? 3.5 : 4.5; // Slightly slower flux in rush hour
                
                this.rainParticles.material.opacity = this.isRaining ? 1 : 0;
                
                this.sun.intensity = (s==='night'||s==='outage'||s==='rain')?0.05:1.0;
                this.ambient.intensity = s==='rain'?0.1:((s==='night'||s==='outage')?0.3:1.4);
                this.ambient.color.setHex(s==='rain'?0x64748b : 0xffffff); // Blue-gray tint for rain
                
                this.buildingWindows.forEach(m => {
                    if (s === 'night' || s === 'rain') {
                        m.color.setHex(0xfde047); // Golden glow
                        m.opacity = 0.95;
                    } else if (s === 'outage') {
                        m.color.setHex(0x000000); // Blacked out
                        m.opacity = 1.0;
                    } else {
                        m.color.setHex(0x000000); // Normal black windows
                        m.opacity = 1.0;
                    }
                });
                this.streetLights.forEach(l => {
                    if (s==='night'||s==='outage'||s==='rain') {
                        l.material.color.setHex(s === 'outage' ? 0x000000 : 0xfef9c3);
                    } else {
                        l.material.color.setHex(0x000000);
                    }
                });
            }

            togglePanel() {
                const p = document.getElementById('control-panel');
                const b = document.getElementById('toggle-btn');
                p.classList.toggle('minimized');
                b.innerText = p.classList.contains('minimized') ? '+' : '‚àí';
            }

            animate() {
                // Performance safeguard: Clamp dt to prevent "glitching" or teleporting during lag
                const dt = Math.min(this.clock.getDelta(), 0.033);
                this.updateTrafficLights(dt); 
                this.updateVehicles(dt); 
                this.updatePedestrians(dt);
                
                // Automatic Ambulance Spawning (Every 25s for 4 iterations, then rest)
                this.ambulanceTimer += dt;
                if (this.ambulanceTimer > 25) {
                    this.ambulanceTimer = 0;
                    this.triggerEmergency();
                    this.ambulanceIteration++;
                    if (this.ambulanceIteration > 4) {
                        this.ambulanceIteration = 1;
                        this.ambulanceTimer = -60; // Extra 1-minute safety rest
                    }
                }

                const spawnChance = this.isRush ? 0.08 : 0.02;
                if(Math.random() < spawnChance) this.spawnCar(); 
                
                if (this.isRaining) {
                    const positions = this.rainParticles.geometry.attributes.position.array;
                    for (let i = 1; i < positions.length; i += 3) {
                        positions[i] -= 10;
                        if (positions[i] < 0) positions[i] = 1000;
                    }
                    this.rainParticles.geometry.attributes.position.needsUpdate = true;
                }

                this.controls.update(); 
                this.renderer.render(this.scene, this.camera);
                requestAnimationFrame(() => this.animate());
            }
        }
        const app = new SmartTrafficSystem();
    </script>
</body>
</html>
