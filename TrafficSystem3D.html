<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>üö¶ Next-Gen 3D Traffic Control System</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;700&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: 'Outfit', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; 
            background: #020617;
            overflow: hidden; 
        }
        #canvas-container { width: 100vw; height: 100vh; position: relative; }
        
        /* Control Panel */
        #control-panel {
            position: absolute; top: 20px; left: 20px; z-index: 100;
            background: rgba(15, 23, 42, 0.85); backdrop-filter: blur(20px);
            border-radius: 24px; padding: 25px; width: 360px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            max-height: 90vh; overflow-y: auto;
            color: #f8fafc;
        }
        
        h1 {
            font-size: 1.6rem; margin-bottom: 20px;
            background: linear-gradient(to right, #60a5fa, #a855f7);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: 800; text-align: center;
        }
        
        .section {
            margin-bottom: 18px; padding-bottom: 18px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }
        .section:last-child { border-bottom: none; }
        
        .label {
            display: block; margin-bottom: 10px; font-size: 0.7rem;
            color: #94a3b8; text-transform: uppercase; font-weight: 700;
            letter-spacing: 1.5px;
        }
        
        select, button, input[type="range"] {
            width: 100%; padding: 12px; border-radius: 14px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            background: rgba(30, 41, 59, 0.5); color: #f1f5f9;
            font-size: 0.9rem; cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            margin-bottom: 8px;
        }
        
        button:hover {
            background: rgba(59, 130, 246, 0.2);
            border-color: #3b82f6; transform: translateY(-1px);
        }
        
        button:active { transform: translateY(0); }
        
        .btn-emergency {
            background: linear-gradient(135deg, #ef4444, #991b1b) !important;
            border: none !important; font-weight: 700;
        }
        
        .stat-grid {
            display: grid; grid-template-columns: 1fr 1fr; gap: 10px;
        }
        .stat-card {
            background: rgba(255, 255, 255, 0.03); padding: 12px;
            border-radius: 16px; text-align: center;
        }
        .stat-label { font-size: 0.65rem; color: #64748b; text-transform: uppercase; display: block; }
        .stat-value { font-size: 1rem; font-weight: 700; color: #3b82f6; }
        
        .ped-controls { display: flex; gap: 10px; align-items: center; }

        #loader {
            position: absolute; inset: 0; z-index: 1000;
            background: #020617; display: flex; flex-direction: column;
            align-items: center; justify-content: center; color: white;
        }
        .spinner {
            width: 50px; height: 50px; border: 3px solid rgba(59, 130, 246, 0.1);
            border-top-color: #3b82f6; border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* Responsive Adjustments */
        @media (max-width: 768px) {
            #control-panel { 
                width: calc(100% - 40px); 
                top: 10px; left: 10px; 
                padding: 15px; 
            }
            h1 { font-size: 1.2rem; }
            .stat-grid { grid-template-columns: 1fr 1fr; }
        }

        /* Minimize Logic */
        #control-panel.minimized .section { display: none; }
        #control-panel.minimized h1 { margin-bottom: 0; }
        #control-panel.minimized { width: auto; max-width: 360px; }

        #toggle-btn {
            position: absolute; top: 15px; right: 15px;
            width: 30px; height: 30px; padding: 0; margin: 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px; display: flex; align-items: center;
            justify-content: center; font-size: 1.2rem;
            border: 1px solid rgba(255,255,255,0.1);
        }
    </style>
</head>
<body>
    <div id="loader">
        <div class="spinner"></div>
        <h2 style="margin-top: 20px;">Deploying AI Traffic Infrastructure...</h2>
    </div>

    <div id="control-panel">
        <button id="toggle-btn" onclick="app.togglePanel()">‚àí</button>
        <h1>TRAFFIC CONTROL SYSTEM</h1>
        
        <div class="section">
            <span class="label">üåç Global Environment</span>
            <select id="scenario-select" onchange="app.loadScenario(this.value)">
                <option value="normal">‚òÄÔ∏è Sunny Day - Crystal Clear</option>
                <option value="night">üåô Midnight - Realistic Glow</option>
                <option value="rush">üöó Peak Rush Hour</option>
                <option value="rain">‚õàÔ∏è Heavy Rain - Slick Roads</option>
                <option value="outage">üöß System Power Outage</option>
            </select>
        </div>
        
        <div class="section">
            <span class="label">üîß Traffic Settings</span>
            <button onclick="app.spawnCar()">‚ûï Add Smart Vehicle</button>
            <button class="btn-emergency" onclick="app.triggerEmergency()">üö® SUMMON AMBULANCE</button>
            
            <div class="ped-controls" style="margin-top: 10px;">
                <div style="flex: 1;">
                   <span class="label">üö∂ Pedestrians</span>
                   <input type="range" id="ped-count" min="1" max="10" value="4">
                </div>
                <button onclick="app.spawnPedestrians()" style="width: auto; margin: 0;">Spawn</button>
            </div>
            <button onclick="app.reset()" style="margin-top: 10px; background: rgba(239, 68, 68, 0.1); color: #f87171; border-color: rgba(239, 68, 68, 0.2);">Reset World</button>
        </div>
        
        <div class="section">
            <span class="label">üìà Real-time Analytics</span>
            <div class="stat-grid">
                <div class="stat-card">
                    <span class="stat-label">Active Phase</span>
                    <span class="stat-value" id="phase-display">NORTH</span>
                </div>
                <div class="stat-card">
                    <span class="stat-label">Green Timer</span>
                    <span class="stat-value" id="green-timer">0s</span>
                </div>
                <div class="stat-card">
                    <span class="stat-label">Active Cars</span>
                    <span class="stat-value" id="car-count">0</span>
                </div>
                <div class="stat-card">
                    <span class="stat-label">Efficiency</span>
                    <span class="stat-value" id="efficiency">100%</span>
                </div>
            </div>
        </div>
    </div>
    
    <div id="canvas-container"></div>

    <script src="libs/three.min.js" onerror="alert('Three.js failed to load from libs/')"></script>
    <script src="libs/OrbitControls.js" onerror="alert('OrbitControls failed to load from libs/')"></script>

    <script>
        const CONFIG = {
            STOP_DISTANCE: 165,    // Shifted back to stop before signal poles
            FOLLOW_DISTANCE: 70,
            NORMAL_SPEED: 4.5,
            EMERGENCY_SPEED: 7.8,
            BASE_PHASE_DURATION: 10.0,
            DENSITY_MULTIPLIER: 4.0,
            MAX_PHASE_DURATION: 35.0,
            YELLOW_DURATION: 3.0,
            MAX_CARS_PER_ROAD: 3,
        };

        class SmartTrafficSystem {
            constructor() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 5000);
                this.camera.position.set(500, 450, 500);
                
                this.renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFShadowMap; 
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); // Optimized pixel ratio
                this.renderer.outputEncoding = THREE.sRGBEncoding;
                document.getElementById('canvas-container').appendChild(this.renderer.domElement);
                
                this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                
                this.clock = new THREE.Clock();
                this.vehicles = [];
                this.pedestrians = [];
                this.trafficLights = {};
                this.streetLights = [];
                this.buildingWindows = [];
                
                this.currentPhase = 0; // N, E, S, W
                this.phaseState = 'green';
                this.powerOutage = false;
                this.isRaining = false;
                this.rainParticles = null;
                this.ambulanceTimer = 0;
                this.ambulanceIteration = 1;
                this.init();
            }

            async init() {
                this.buildEnvironment();
                this.createTrafficLights();
                this.setupLights();
                this.loadScenario('normal');
                
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });

                document.getElementById('loader').style.display = 'none';
                this.animate();
            }

            buildEnvironment() {
                // Deep Emerald Ground (#043915)
                const groundGeo = new THREE.PlaneGeometry(5000, 5000);
                const groundMat = new THREE.MeshStandardMaterial({ color: 0x043915, roughness: 1 });
                const ground = new THREE.Mesh(groundGeo, groundMat);
                ground.rotation.x = -Math.PI / 2;
                ground.receiveShadow = true;
                this.scene.add(ground);

                // Optimized Road Layering (Dark Charcoal Grey)
                const roadMat = new THREE.MeshLambertMaterial({ color: 0x1e293b });
                const roadNS = new THREE.Mesh(new THREE.PlaneGeometry(90, 5000), roadMat);
                roadNS.rotation.x = -Math.PI / 2;
                roadNS.position.y = 1.0; // Increased spacing to stop glitching
                this.scene.add(roadNS);
                
                const roadEW = new THREE.Mesh(new THREE.PlaneGeometry(5000, 90), roadMat);
                roadEW.rotation.x = -Math.PI / 2;
                roadEW.position.y = 1.1; // Increased spacing to stop glitching
                this.scene.add(roadEW);

                // Road Center Lines (Dotted)
                const lineMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                for(let i = -2500; i < 2500; i += 60) {
                    if (Math.abs(i) < 120) continue;
                    const dashNS = new THREE.Mesh(new THREE.PlaneGeometry(4, 30), lineMat);
                    dashNS.rotation.x = -Math.PI/2;
                    dashNS.position.set(0, 1.2, i); 
                    this.scene.add(dashNS);

                    const dashEW = new THREE.Mesh(new THREE.PlaneGeometry(30, 4), lineMat);
                    dashEW.rotation.x = -Math.PI/2;
                    dashEW.position.set(i, 1.25, 0); 
                    this.scene.add(dashEW);
                }

                // Curbings to prevent "vanishing" look
                const curbMat = new THREE.MeshStandardMaterial({ color: 0x334155 });
                const curbs = [
                    { w: 10, h: 5000, x: 50, z: 0 }, { w: 10, h: 5000, x: -50, z: 0 },
                    { w: 5000, h: 10, x: 0, z: 50 }, { w: 5000, h: 10, x: 0, z: -50 }
                ];
                curbs.forEach(c => {
                    const curb = new THREE.Mesh(new THREE.PlaneGeometry(c.w, c.h), curbMat);
                    curb.rotation.x = -Math.PI/2;
                    curb.position.set(c.x, 0.4, c.z); // Clean offset
                    this.scene.add(curb);
                });

                // Clearer Zebra Markings
                const zebraMat = new THREE.MeshBasicMaterial({ color: 0xf8fafc });
                const crossings = [
                    { x: 0, z: -100, rot: 0 }, { x: 0, z: 100, rot: 0 },
                    { x: -100, z: 0, rot: Math.PI/2 }, { x: 100, z: 0, rot: Math.PI/2 }
                ];
                crossings.forEach(c => {
                    for(let i=-4; i<=4; i++) {
                        const s = new THREE.Mesh(new THREE.PlaneGeometry(6, 28), zebraMat);
                        s.rotation.x = -Math.PI/2;
                        s.rotation.z = c.rot;
                        s.position.set(c.x + (c.rot?0:i*9), 1.2, c.z + (c.rot?i*9:0)); 
                        this.scene.add(s);
                    }
                });

                // Society Houses (Professional Dark Roofs)
                const roofColors = [0x1e293b, 0x334155, 0x020617, 0x451a03, 0x422006];
                const houseBodyMat = new THREE.MeshLambertMaterial({ color: 0xf1f5f9 });
                
                const houseWinGeo = new THREE.PlaneGeometry(12, 10);
                const houseWinMat = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0 });
                this.buildingWindows.push(houseWinMat);

                for (let i = 0; i < 48; i++) {
                    const quadrant = i % 4;
                    const row = Math.floor(i / 8);
                    const col = i % 8;
                    let hX, hZ;
                    
                    if (quadrant === 0) { hX = 150 + col * 90; hZ = 150 + row * 110; }
                    else if (quadrant === 1) { hX = -150 - col * 90; hZ = 150 + row * 110; }
                    else if (quadrant === 2) { hX = 150 + col * 90; hZ = -150 - row * 110; }
                    else { hX = -150 - col * 90; hZ = -150 - row * 110; }

                    const houseGrp = new THREE.Group();
                    houseGrp.position.set(hX, 0, hZ);
                    const body = new THREE.Mesh(new THREE.BoxGeometry(45, 25, 45), houseBodyMat);
                    body.position.y = 12.5; body.castShadow = true; houseGrp.add(body);
                    const roof = new THREE.Mesh(new THREE.ConeGeometry(40, 22, 4), new THREE.MeshLambertMaterial({ color: roofColors[i % 5] }));
                    roof.position.y = 36; roof.rotation.y = Math.PI/4; houseGrp.add(roof);
                    
                    const win = new THREE.Mesh(houseWinGeo, houseWinMat);
                    win.position.set(0, 15, 22.6); houseGrp.add(win);
                    const winSide = win.clone(); winSide.position.set(22.6, 15, 0); winSide.rotation.y = Math.PI/2; houseGrp.add(winSide);
                    this.scene.add(houseGrp);
                }

                // Society Street Signs
                const addSign = (x, z, rot, label) => {
                    const group = new THREE.Group();
                    group.position.set(x, 0, z); group.rotation.y = rot;
                    const pole = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 1.5, 45), new THREE.MeshLambertMaterial({color: 0x334155}));
                    pole.position.y = 22.5; group.add(pole);
                    
                    const can = document.createElement('canvas');
                    can.width = 256; can.height = 128;
                    const c = can.getContext('2d');
                    c.fillStyle = '#1e293b'; c.fillRect(0,0,256,128);
                    c.font = 'bold 40px Arial'; c.fillStyle = '#ffffff'; c.textAlign = 'center';
                    c.fillText(label, 128, 75);
                    
                    const board = new THREE.Mesh(new THREE.BoxGeometry(40, 15, 2), new THREE.MeshBasicMaterial({map: new THREE.CanvasTexture(can)}));
                    board.position.y = 40; group.add(board);
                    this.scene.add(group);
                };
                
                addSign(70, 140, 0, "STREET NO1");
                addSign(-70, 140, 0, "STREET NO2");
                addSign(70, -140, Math.PI, "STREET NO3");
                addSign(-70, -140, Math.PI, "STREET NO4");

                // Skyline Buildings (Optimized with Instanced Windows)
                const winGeo = new THREE.PlaneGeometry(8, 12);
                const winMat = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 1.0 });
                this.buildingWindows.push(winMat);
                const winInst = new THREE.InstancedMesh(winGeo, winMat, 40000);
                let winIdx = 0;
                const winDummy = new THREE.Object3D();

                const buildColors = [0x334155, 0x475569, 0x1e293b, 0x3f6075, 0x4a5d4e]; 
                for (let i = 0; i < 70; i++) {
                    const x = (Math.random() - 0.5) * 4500;
                    const z = (Math.random() - 0.5) * 4500;
                    if (Math.abs(x) < 140 || Math.abs(z) < 140) continue; 
                    if (Math.abs(x) < 850 && Math.abs(z) < 850) continue;
                    
                    const h = 250 + Math.random() * 600;
                    const w = 70 + Math.random() * 90;
                    const b = new THREE.Mesh(new THREE.BoxGeometry(w, h, w), new THREE.MeshLambertMaterial({ color: buildColors[i % 5] }));
                    b.position.set(x, h/2, z); b.castShadow = true; this.scene.add(b);
                    
                    // Add instanced windows
                    const rows = Math.floor(h / 30);
                    const cols = Math.floor(w / 15);
                    for(let r=1; r<rows; r++) {
                        for(let c=1; c<cols; c++) {
                            if (winIdx >= 39999) break;
                            // Front face
                            winDummy.position.set(x -w/2 + c*15, r*30, z + w/2 + 0.1);
                            winDummy.rotation.set(0, 0, 0);
                            winDummy.updateMatrix();
                            winInst.setMatrixAt(winIdx++, winDummy.matrix);
                            // Back face
                            winDummy.position.z = z - w/2 - 0.1;
                            winDummy.rotation.y = Math.PI;
                            winDummy.updateMatrix();
                            winInst.setMatrixAt(winIdx++, winDummy.matrix);
                        }
                    }
                }
                winInst.count = winIdx;
                this.scene.add(winInst);

                // Zig-Zag Street Lamps & Roadside Bushes
                // Optimized Geometry: Instancing for bushes and flowers
                const bushGeo = new THREE.SphereGeometry(6, 6, 6);
                const flowerGeo = new THREE.SphereGeometry(1.5, 4, 4);
                const bushMat = new THREE.MeshLambertMaterial({ color: 0x166534 });
                const flowerColors = [0xef4444, 0xec4899, 0xa855f7];
                
                // Pre-count instances (Approx 1000)
                const bushInst = new THREE.InstancedMesh(bushGeo, bushMat, 1000);
                const flowerInst = new THREE.InstancedMesh(flowerGeo, new THREE.MeshLambertMaterial({color: 0xef4444}), 1000);
                let instIdx = 0;

                const dummy = new THREE.Object3D();

                for(let i = -1400; i < 1400; i += 40) {
                    if (Math.abs(i) < 180) continue;
                    
                    if (i % 80 === 0) {
                        const side = (i % 160 === 0) ? 1 : -1;
                        // Lamps NS
                        const lampNS = new THREE.Group();
                        lampNS.position.set(65 * side, 0, i);
                        const poleNS = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 2.5, 70), new THREE.MeshLambertMaterial({color: 0x020617}));
                        poleNS.position.y = 35; lampNS.add(poleNS);
                        const armNS = new THREE.Mesh(new THREE.BoxGeometry(15, 2, 2), new THREE.MeshLambertMaterial({color: 0x020617}));
                        armNS.position.set(side > 0 ? -7 : 7, 70, 0); lampNS.add(armNS);
                        const lightNS = new THREE.PointLight(0xfef9c3, 0, 250, 2); // Reduced range
                        lightNS.position.set(side > 0 ? -12: 12, 70, 0); lampNS.add(lightNS);
                        this.streetLights.push(lightNS);
                        this.scene.add(lampNS);

                        // Lamps EW
                        const lampEW = new THREE.Group();
                        lampEW.position.set(i, 0, 65 * side);
                        lampEW.rotation.y = Math.PI/2;
                        const poleEW = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 2.5, 70), new THREE.MeshLambertMaterial({color: 0x020617}));
                        poleEW.position.y = 35; lampEW.add(poleEW);
                        const armEW = new THREE.Mesh(new THREE.BoxGeometry(15, 2, 2), new THREE.MeshLambertMaterial({color: 0x020617}));
                        armEW.position.set(side > 0 ? 7 : -7, 70, 0); lampEW.add(armEW);
                        const lightEW = new THREE.PointLight(0xfef9c3, 0, 250, 2);
                        lightEW.position.set(side > 0 ? 12: -12, 70, 0); lampEW.add(lightEW);
                        this.streetLights.push(lightEW);
                        this.scene.add(lampEW);

                        // Bushes (Instanced)
                        const roads = [{x: 48, z: i, rot: 0}, {x: -48, z: i, rot: 0}, {x: i, z: 48, rot: Math.PI/2}, {x: i, z: -48, rot: Math.PI/2}];
                        roads.forEach(r => {
                            const clusterSize = Math.random() < 0.4 ? 2 : 1;
                            for(let c=0; c<clusterSize; c++) {
                                const offset = (c-clusterSize/2) * 8;
                                dummy.position.set(r.x + (r.rot?0:offset/2), 3, r.z + (r.rot?offset/2:0));
                                dummy.scale.set(1, 0.6, 1);
                                dummy.updateMatrix();
                                bushInst.setMatrixAt(instIdx, dummy.matrix);
                                
                                dummy.position.y = 6;
                                dummy.scale.set(1, 1, 1);
                                dummy.updateMatrix();
                                flowerInst.setMatrixAt(instIdx, dummy.matrix);
                                instIdx++;
                            }
                        });
                    }
                }
                bushInst.count = instIdx;
                flowerInst.count = instIdx;
                this.scene.add(bushInst, flowerInst);

                // Rain Particles (Hidden by default)
                const rainGeo = new THREE.BufferGeometry();
                const rainCount = 2000;
                const rainPoints = [];
                for(let i=0; i<rainCount; i++) {
                    rainPoints.push((Math.random()-0.5)*2000, Math.random()*1000, (Math.random()-0.5)*2000);
                }
                rainGeo.setAttribute('position', new THREE.Float32BufferAttribute(rainPoints, 3));
                const rainMat = new THREE.PointsMaterial({color: 0xaaaaaa, size: 2, transparent: true, opacity: 0});
                this.rainParticles = new THREE.Points(rainGeo, rainMat);
                this.scene.add(this.rainParticles);
            }

            createTrafficLights() {
                const userSigConfig = [
                    { dir: 'N', x: -65, z: -140, rot: Math.PI, arm: 25 }, 
                    { dir: 'S', x: 65, z: 140, rot: 0, arm: 25 },           
                    { dir: 'E', x: 140, z: -65, rot: Math.PI/2, arm: 25 },  
                    { dir: 'W', x: -140, z: 65, rot: -Math.PI/2, arm: 25 }  
                ];

                userSigConfig.forEach(p => {
                    const group = new THREE.Group();
                    group.position.set(p.x, 0, p.z); group.rotation.y = p.rot;
                    
                    const pole = new THREE.Mesh(new THREE.BoxGeometry(4, 70, 4), new THREE.MeshLambertMaterial({color: 0x000000}));
                    pole.position.y = 35; group.add(pole);

                    const arm = new THREE.Mesh(new THREE.BoxGeometry(p.arm, 4, 4), new THREE.MeshLambertMaterial({color: 0x000000}));
                    arm.position.set(p.arm/2, 65, 0); group.add(arm);

                    const box = new THREE.Mesh(new THREE.BoxGeometry(16, 32, 10), new THREE.MeshLambertMaterial({color: 0x000000}));
                    box.position.set(p.arm, 65, 0); group.add(box);
                    
                    const bulbGeo = new THREE.SphereGeometry(4.5, 16, 16);
                    const r = new THREE.Mesh(bulbGeo, new THREE.MeshStandardMaterial({color: 0x220000, emissive: 0x000000}));
                    r.position.set(p.arm, 75, 6); group.add(r);
                    const y = new THREE.Mesh(bulbGeo, new THREE.MeshStandardMaterial({color: 0x222200, emissive: 0x000000}));
                    y.position.set(p.arm, 65, 6); group.add(y);
                    const g = new THREE.Mesh(bulbGeo, new THREE.MeshStandardMaterial({color: 0x002200, emissive: 0x000000}));
                    g.position.set(p.arm, 55, 6); group.add(g);
                    
                    this.scene.add(group);
                    this.trafficLights[p.dir] = { red:r, yellow:y, green:g, state: 'red' };
                });
            }

            setupLights() {
                this.ambient = new THREE.AmbientLight(0xffffff, 1.4); this.scene.add(this.ambient);
                this.sun = new THREE.DirectionalLight(0xffffff, 1.0); this.sun.position.set(600, 1000, 300); this.scene.add(this.sun);
            }

            spawnCar(lane = null, type = 'normal') {
                const lanes = ['N', 'E', 'S', 'W'];
                const targetLane = lane || lanes[Math.floor(Math.random() * 4)];
                if (this.vehicles.filter(v => v.lane === targetLane).length >= CONFIG.MAX_CARS_PER_ROAD) return;

                const car = new THREE.Group();
                const categories = ['car', 'jeep', 'bus'];
                const category = type === 'ambulance' ? 'ambulance' : categories[Math.floor(Math.random() * categories.length)];
                
                const colors = [0x3b82f6, 0xef4444, 0x10b981, 0xf59e0b, 0xffffff, 0x8b5cf6];
                const mainColor = type === 'ambulance' ? 0xffffff : colors[Math.floor(Math.random()*colors.length)];
                const mat = new THREE.MeshStandardMaterial({color: mainColor, roughness: 0.1});
                const winMat = new THREE.MeshBasicMaterial({color: 0x000000});
                const wheelMat = new THREE.MeshLambertMaterial({color: 0x111111});
                const wheelGeo = new THREE.CylinderGeometry(3.2, 3.2, 3, 16);
                
                let bodyW = 18, bodyH = 8, bodyL = 32;
                
                // Specific Shape Logic
                if (category === 'car') {
                    bodyH = 6; bodyL = 30;
                    const body = new THREE.Mesh(new THREE.BoxGeometry(bodyW, bodyH, bodyL), mat);
                    body.position.y = 7; body.castShadow = true; car.add(body);
                    const cabin = new THREE.Mesh(new THREE.BoxGeometry(16, 5, 16), mat);
                    cabin.position.set(0, 12, -2); car.add(cabin);
                    // Windows
                    const fw = new THREE.Mesh(new THREE.PlaneGeometry(14, 3.5), winMat);
                    fw.position.set(0, 12, 6.1); car.add(fw);
                    const sw = new THREE.Mesh(new THREE.PlaneGeometry(13, 3.5), winMat);
                    sw.position.set(8.1, 12, -2); sw.rotation.y = Math.PI/2; car.add(sw);
                    const sw2 = sw.clone(); sw2.position.x = -8.1; sw2.rotation.y = -Math.PI/2; car.add(sw2);
                } else if (category === 'jeep') {
                    bodyH = 12; bodyL = 28;
                    const body = new THREE.Mesh(new THREE.BoxGeometry(bodyW, bodyH, bodyL), mat);
                    body.position.y = 10; body.castShadow = true; car.add(body);
                    // Windows
                    const fw = new THREE.Mesh(new THREE.PlaneGeometry(15, 6), winMat);
                    fw.position.set(0, 13, 14.1); car.add(fw);
                    const sw = new THREE.Mesh(new THREE.PlaneGeometry(20, 6), winMat);
                    sw.position.set(9.1, 13, 0); sw.rotation.y = Math.PI/2; car.add(sw);
                    const sw2 = sw.clone(); sw2.position.x = -9.1; sw2.rotation.y = -Math.PI/2; car.add(sw2);
                } else if (category === 'bus') {
                    bodyH = 16; bodyL = 52;
                    const body = new THREE.Mesh(new THREE.BoxGeometry(bodyW, bodyH, bodyL), mat);
                    body.position.y = 12; body.castShadow = true; car.add(body);
                    // Windows
                    const sw = new THREE.Mesh(new THREE.PlaneGeometry(45, 8), winMat);
                    sw.position.set(9.1, 15, 0); sw.rotation.y = Math.PI/2; car.add(sw);
                    const sw2 = sw.clone(); sw2.position.x = -9.1; sw2.rotation.y = -Math.PI/2; car.add(sw2);
                    const fw = new THREE.Mesh(new THREE.PlaneGeometry(15, 10), winMat);
                    fw.position.set(0, 15, 26.1); car.add(fw);
                } else if (category === 'ambulance') {
                    bodyH = 13; bodyL = 34;
                    const body = new THREE.Mesh(new THREE.BoxGeometry(bodyW, bodyH, bodyL), mat);
                    body.position.y = 10.5; body.castShadow = true; car.add(body);
                    // Windows
                    const fw = new THREE.Mesh(new THREE.PlaneGeometry(15, 6), winMat);
                    fw.position.set(0, 13, 17.1); car.add(fw);
                    const sw = new THREE.Mesh(new THREE.PlaneGeometry(12, 5), winMat);
                    sw.position.set(9.1, 13, 8); sw.rotation.y = Math.PI/2; car.add(sw);
                    const sw2 = sw.clone(); sw2.position.x = -9.1; sw2.rotation.y = -Math.PI/2; car.add(sw2);
                }

                // Add 4 Wheels
                const wheelPositions = [
                    {x: 8, z: bodyL/2 - 6}, {x: -8, z: bodyL/2 - 6},
                    {x: 8, z: -bodyL/2 + 6}, {x: -8, z: -bodyL/2 + 6}
                ];
                wheelPositions.forEach(p => {
                    const w = new THREE.Mesh(wheelGeo, wheelMat);
                    w.rotation.z = Math.PI/2;
                    w.position.set(p.x, 3.2, p.z);
                    car.add(w);
                });

                const laneConfigs = {
                    N: { x: -40, z: -2000, rot: 0, axis: 'z', dir: 1 },
                    S: { x: 40, z: 2000, rot: Math.PI, axis: 'z', dir: -1 },
                    E: { x: 2000, z: -40, rot: -Math.PI/2, axis: 'x', dir: -1 },
                    W: { x: -2000, z: 40, rot: Math.PI/2, axis: 'x', dir: 1 }
                };
                const config = laneConfigs[targetLane];

                let hlColor = 0xfff9c4;
                if (targetLane === 'W') hlColor = 0xffffff;
                if (targetLane === 'S') hlColor = 0xffe082;
                 
                const hl = new THREE.Mesh(new THREE.CircleGeometry(3, 32), new THREE.MeshBasicMaterial({color: hlColor}));
                hl.position.set(-6, 8, bodyL/2 + 0.1); car.add(hl);
                const hr = hl.clone(); hr.position.x = 6; car.add(hr);
                const beam = new THREE.SpotLight(0xfff08a, 6, 400, 0.5); beam.position.set(0, 8, bodyL/2 + 1);
                const tObj = new THREE.Object3D(); tObj.position.set(0, 0, 100); car.add(tObj);
                beam.target = tObj; car.add(beam);

                const bl = new THREE.Mesh(new THREE.CircleGeometry(3, 32), new THREE.MeshBasicMaterial({color: 0x600000}));
                bl.position.set(-6, 8, -bodyL/2 - 0.1); bl.rotation.y = Math.PI; car.add(bl);
                const br = bl.clone(); br.position.x = 6; car.add(br);

                let sirens = null;
                if(category === 'ambulance') {
                    sirens = new THREE.Mesh(new THREE.BoxGeometry(14, 3, 5), new THREE.MeshBasicMaterial({color: 0xffffff}));
                    sirens.position.y = bodyH + 8; car.add(sirens);
                }

                car.position.set(config.x, 0, config.z);
                car.rotation.y = config.rot;
                this.scene.add(car);
                this.vehicles.push({ mesh: car, lane: targetLane, type: category, speed: 0, maxSpeed: category==='ambulance'?CONFIG.EMERGENCY_SPEED:CONFIG.NORMAL_SPEED, config, brakeLights: [bl, br], headLight: beam, sirens, status: 'moving' });
            }

            spawnPedestrians() {
                const count = parseInt(document.getElementById('ped-count').value);
                const corners = [
                    { x: -80, z: -150, dx: 0, dz: 1, side: 'N' }, 
                    { x: 80, z: 150, dx: 0, dz: -1, side: 'S' }, 
                    { x: -150, z: 80, dx: 1, dz: 0, side: 'W' }, 
                    { x: 150, z: -80, dx: -1, dz: 0, side: 'E' }
                ];
                
                const clothColors = [0x3b82f6, 0xef4444, 0x10b981, 0xf59e0b, 0xffffff];
                
                corners.forEach(corner => {
                    for(let i=0; i<count; i++) {
                        const group = new THREE.Group();
                        
                        // Head
                        const head = new THREE.Mesh(new THREE.SphereGeometry(2, 8, 8), new THREE.MeshLambertMaterial({color: 0xffdbac}));
                        head.position.y = 14; group.add(head);
                        
                        // Torso (Clothing)
                        const torso = new THREE.Mesh(new THREE.BoxGeometry(3, 6, 2), new THREE.MeshLambertMaterial({color: clothColors[Math.floor(Math.random()*5)]}));
                        torso.position.y = 10; group.add(torso);
                        
                        // Legs
                        const legGeo = new THREE.BoxGeometry(1, 4, 1);
                        const legL = new THREE.Mesh(legGeo, new THREE.MeshLambertMaterial({color: 0x1e293b}));
                        legL.position.set(-1, 5, 0); group.add(legL);
                        const legR = legL.clone();
                        legR.position.x = 1; group.add(legR);
                        
                        group.position.set(corner.x + (corner.dx?0:(Math.random()-0.5)*25), 0, corner.z + (corner.dz?0:(Math.random()-0.5)*25));
                        this.scene.add(group);
                        this.pedestrians.push({ mesh: group, legs: [legL, legR], dir: { x: corner.dx, z: corner.dz }, side: corner.side, distance: 0, status: 'waiting' });
                    }
                });
            }

            updateTrafficLights(dt) {
                if (this.powerOutage) {
                    this.phaseTime += dt; const blink = Math.floor(this.phaseTime * 2) % 2;
                    Object.values(this.trafficLights).forEach(l => {
                        l.red.material.emissive.setHex(0); l.green.material.emissive.setHex(0);
                        l.yellow.material.emissive.setHex(blink ? 0xffea00 : 0); l.state = 'outage';
                    });
                    return;
                }

                const phases = ['NORTH', 'EAST', 'SOUTH', 'WEST'];
                const laneKeys = ['N', 'E', 'S', 'W'];
                this.phaseTime += dt;
                
                const density = { N: 0, E: 0, S: 0, W: 0 };
                this.vehicles.forEach(v => {
                    const dist = Math.abs(v.mesh.position[v.config.axis]);
                    if (dist > CONFIG.STOP_DISTANCE && dist < 500 && (v.mesh.position[v.config.axis] * v.config.dir < 0)) density[v.lane]++;
                });

                this.dynamicDuration = Math.min(CONFIG.MAX_PHASE_DURATION, CONFIG.BASE_PHASE_DURATION + (density[laneKeys[this.currentPhase]] * CONFIG.DENSITY_MULTIPLIER));

                // LANE CLEARING CHECK: Are there still cars inside the intersection?
                const activeLane = laneKeys[this.currentPhase];
                const carsClearing = this.vehicles.some(v => v.lane === activeLane && Math.abs(v.mesh.position[v.config.axis]) < 180);

                // SMART SKIP: Only skip if road is EMPTY and intersection is CLEAR
                if (this.phaseState === 'green' && density[activeLane] === 0 && !carsClearing && this.phaseTime > 3.0) {
                    this.dynamicDuration = 3.0;
                }

                // AMBULANCE PRIORITY: Forced override
                const priorityAmbulance = this.vehicles.find(v => v.type === 'ambulance' && Math.abs(v.mesh.position[v.config.axis]) < 700 && (v.mesh.position[v.config.axis] * v.config.dir < 0));
                if (priorityAmbulance) {
                    const ambPhase = laneKeys.indexOf(priorityAmbulance.lane);
                    if (this.currentPhase !== ambPhase || this.phaseState !== 'green') {
                        this.currentPhase = ambPhase;
                        this.phaseState = 'green';
                        this.phaseTime = 0;
                    }
                }
                
                // Switch phase only if time is up AND intersection is clear
                if(this.phaseTime > (this.phaseState === 'green' ? this.dynamicDuration : CONFIG.YELLOW_DURATION)) {
                    // Force wait if cars are still clearing the path
                    if (this.phaseState === 'green' && carsClearing && !priorityAmbulance) return; 

                    if (this.phaseState === 'green') { this.phaseState = 'yellow'; this.phaseTime = 0; }
                    else { this.phaseState = 'green'; this.phaseTime = 0; this.currentPhase = (this.currentPhase + 1) % 4; }
                }

                Object.keys(this.trafficLights).forEach(dir => {
                    const l = this.trafficLights[dir];
                    const active = (dir === laneKeys[this.currentPhase]);
                    if (active) {
                        if (this.phaseState === 'green') { l.red.material.emissive.setHex(0); l.yellow.material.emissive.setHex(0); l.green.material.emissive.setHex(0x00ff00); l.state = 'green'; }
                        else { l.red.material.emissive.setHex(0); l.yellow.material.emissive.setHex(0xffff00); l.green.material.emissive.setHex(0); l.state = 'yellow'; }
                    } else { l.red.material.emissive.setHex(0xff0000); l.yellow.material.emissive.setHex(0); l.green.material.emissive.setHex(0); l.state = 'red'; }
                });
                document.getElementById('phase-display').innerText = phases[this.currentPhase];
                document.getElementById('green-timer').innerText = Math.ceil((this.phaseState==='green'?this.dynamicDuration:CONFIG.YELLOW_DURATION) - this.phaseTime) + "s";
            }

            updateVehicles(dt) {
                this.vehicles.forEach((v, i) => {
                    const pos = v.mesh.position;
                    const axis = v.config.axis;
                    const dir = v.config.dir;
                    const dist = Math.abs(pos[axis]);
                    const movingTowardsCenter = (pos[axis] * dir < 0);
                    let target = v.maxSpeed;
                    v.status = 'moving';

                    if (movingTowardsCenter) {
                        const light = this.trafficLights[v.lane];
                        // Power Outage Caution: Slow down and check cross-traffic
                        if (this.powerOutage) {
                            target = Math.min(target, 0.8);
                            if (dist < 120 && dist > 100) {
                                // Simple yield logic: If someone is in square, stop
                                const bugInIntersection = this.vehicles.some(other => 
                                    other !== v && 
                                    Math.abs(other.mesh.position.x) < 80 && 
                                    Math.abs(other.mesh.position.z) < 80
                                );
                                if (bugInIntersection) { target = 0; v.status = 'braking'; }
                            }
                        } else if ((light.state === 'red' || light.state === 'yellow') && v.type !== 'ambulance') {
                            const distToLine = dist - CONFIG.STOP_DISTANCE;
                            if (distToLine > 0) {
                                target = Math.max(0, Math.min(v.maxSpeed, distToLine / 25)); // Slightly tighter deceleration
                                if (distToLine < 15) v.status = 'braking'; 
                            } else {
                                target = 0;
                            }
                        }
                        
                        // UNIVERSAL COLLISION RADAR (Avoids any vehicle in path)
                        this.vehicles.forEach(other => {
                            if (other === v) return;
                            
                            // Same lane following
                            if (other.lane === v.lane) {
                                const gap = (pos[axis] - other.mesh.position[axis]) * -dir;
                                if (gap > 0 && gap < CONFIG.FOLLOW_DISTANCE + 10) {
                                    target = Math.min(target, other.speed * 0.7);
                                    if (gap < CONFIG.FOLLOW_DISTANCE) { target = 0; v.status = 'braking'; }
                                }
                            } 
                            // Intersection check (Crucial for Ambulance Safety)
                            else if (Math.abs(pos.x) < 150 && Math.abs(pos.z) < 150) {
                                const distToOther = pos.distanceTo(other.mesh.position);
                                if (distToOther < 60) {
                                    // If other is directly in front path
                                    const relDir = other.mesh.position.clone().sub(pos).normalize();
                                    const carForward = new THREE.Vector3(0,0,1).applyQuaternion(v.mesh.quaternion);
                                    if (relDir.dot(carForward) > 0.8) {
                                        target = 0; v.status = 'braking';
                                    }
                                }
                            }
                        });
                    }

                    if (v.speed < target) v.speed += (this.isRaining ? 0.08 : 0.4); // Snappier acceleration
                    else if (v.speed > target) v.speed -= 1.2; // Optimized braking for high-speed protocol
                    if (v.speed < 0.1) v.speed = 0;

                    pos[axis] += v.speed * dir;
                    v.brakeLights.forEach(l => l.material.color.setHex((v.status === 'braking' || v.speed < 0.2) ? 0xff0000 : 0x400000));
                    
                    if(v.sirens) {
                        const flash = Math.floor(Date.now() / 150) % 2;
                        v.sirens.material.color.setHex(flash ? 0xff0000 : 0xffffff);
                    }

                    if (dist > 2500) { this.scene.remove(v.mesh); this.vehicles.splice(i, 1); }
                });
                document.getElementById('car-count').innerText = this.vehicles.length;
            }

            updatePedestrians(dt) {
                this.pedestrians.forEach((p, i) => {
                    const light = this.trafficLights[p.side];
                    let canWalk = (light.state === 'red'); // Pedestrians cross when vehicle signal is RED

                    // If they haven't reached the crossing yet, or they are already crossing
                    const isAtCrossing = (p.distance > 20 && p.distance < 160);
                    
                    if (isAtCrossing && !canWalk) {
                        p.status = 'waiting';
                    } else {
                        p.status = 'walking';
                        p.distance += 0.8;
                        p.mesh.position.x += p.dir.x * 0.8;
                        p.mesh.position.z += p.dir.z * 0.8;
                        
                        // Walking Animation
                        p.mesh.position.y = Math.abs(Math.sin(p.distance * 0.2)) * 1;
                        p.legs[0].rotation.x = Math.sin(p.distance * 0.2) * 0.5;
                        p.legs[1].rotation.x = -Math.sin(p.distance * 0.2) * 0.5;
                    }

                    if (p.distance > 350) {
                        this.scene.remove(p.mesh);
                        this.pedestrians.splice(i, 1);
                    }
                });
            }

            triggerEmergency() { this.spawnCar(null, 'ambulance'); }
            reset() { this.vehicles.forEach(v => this.scene.remove(v.mesh)); this.vehicles = []; this.pedestrians.forEach(p => this.scene.remove(p.mesh)); this.pedestrians = []; this.phaseTime = 0; }
            
            loadScenario(s) { 
                this.reset();
                this.powerOutage = (s === 'outage');
                this.isRaining = (s === 'rain');
                this.rainParticles.material.opacity = this.isRaining ? 1 : 0;
                
                this.sun.intensity = (s==='night'||s==='outage'||s==='rain')?0.05:1.0;
                this.ambient.intensity = s==='rain'?0.1:((s==='night'||s==='outage')?0.3:1.4);
                this.ambient.color.setHex(s==='rain'?0x64748b : 0xffffff); // Blue-gray tint for rain
                
                this.buildingWindows.forEach(m => {
                    if (s === 'night' || s === 'rain') {
                        m.color.setHex(0xfde047); // Golden glow
                        m.opacity = 0.95;
                    } else if (s === 'outage') {
                        m.color.setHex(0x000000); // Blacked out
                        m.opacity = 1.0;
                    } else {
                        m.color.setHex(0x000000); // Normal black windows
                        m.opacity = 1.0;
                    }
                });
                this.streetLights.forEach(l => l.intensity = (s==='night'||s==='outage'||s==='rain')?4:0);
            }

            togglePanel() {
                const p = document.getElementById('control-panel');
                const b = document.getElementById('toggle-btn');
                p.classList.toggle('minimized');
                b.innerText = p.classList.contains('minimized') ? '+' : '‚àí';
            }

            animate() {
                // Performance safeguard: Clamp dt to prevent "glitching" or teleporting during lag
                const dt = Math.min(this.clock.getDelta(), 0.033);
                this.updateTrafficLights(dt); 
                this.updateVehicles(dt); 
                this.updatePedestrians(dt);
                
                // Automatic Ambulance Spawning (Every 25s for 4 iterations, then rest)
                this.ambulanceTimer += dt;
                if (this.ambulanceTimer > 25) {
                    this.ambulanceTimer = 0;
                    this.triggerEmergency();
                    this.ambulanceIteration++;
                    if (this.ambulanceIteration > 4) {
                        this.ambulanceIteration = 1;
                        this.ambulanceTimer = -60; // Extra 1-minute safety rest
                    }
                }

                if(Math.random() < 0.02) this.spawnCar(); 
                
                if (this.isRaining) {
                    const positions = this.rainParticles.geometry.attributes.position.array;
                    for (let i = 1; i < positions.length; i += 3) {
                        positions[i] -= 10;
                        if (positions[i] < 0) positions[i] = 1000;
                    }
                    this.rainParticles.geometry.attributes.position.needsUpdate = true;
                }

                this.controls.update(); 
                this.renderer.render(this.scene, this.camera);
                requestAnimationFrame(() => this.animate());
            }
        }
        const app = new SmartTrafficSystem();
    </script>
</body>
</html>
